let e,t;const n=[],o=new(WeakMap||Map),r=new(WeakMap||Map),s=r=>(function s(){const a=n[t][0];e++;const i=n[t][e]||(n[t][e]=[{context:a,hook:r}]);return(o.get(s)||r).apply({},i.concat(Array.from(arguments)))}),a=(e,o)=>{const s=n[t].map(e=>{if(e[0]&&e[0][o]){const t=e[0][o]();return e[0][o]=0,t}}).filter(e=>e instanceof Promise);if(s.length>0){const t=Promise.all(s);r.set(e,r.has(e)?r.get(e).then(t):t)}},i=(e,t)=>{if(r.has(e)){const n=r.get(e).then(t);return r.set(e,n),n}return t()},c=function(){const s=Array.from(arguments);let c;return s[0].pop&&(c=s.shift()),((s,c,p,l)=>{if(!0!==c)return i(s,()=>(e=0,t=n.push(o.get(s)||[s])-1,o.set(s,n[t]),a(s,"before"),i(s,()=>{let e=p.apply(p,l);return a(s,"after"),i(s,()=>(n.pop(),r.delete(s),e))})));r.set(s,a(s,"cleanUp")),o.delete(s)})("boolean"==typeof s[1]?s[0]:s[1]||s[0],!0===s[1]||s[2],s[0],c)},p=s((e,t,n,o)=>(e.s=void 0!==e.s?e.s:o?o(n):n,[e.s,n=>(e.s=t(e.s,n),e.s)])),l=s((e,t,n)=>{e.v&&(!n||n.length===e.v.length&&n.every(t=>~e.v.indexOf(t)))||(e.v=n,e.cleanUp&&e.cleanUp(),e.after=(()=>{let n=t();return n instanceof Promise?n=n.then(t=>e.cleanUp=t):e.cleanUp=n,n}))}),u=(e,t)=>{l(()=>new Promise(t=>requestAnimationFrame(n=>t(e()))),t)},h=e=>{const[t,n]=p((e,t)=>t.value,e);return[t,e=>n({value:e})]},d=s(e=>e.context),f=[];let v,m=!1;const b=async()=>{if(!m&&f.length>0){v=v||Date.now(),m=!0;const e=f.pop();await e.render();const t=()=>{m=!1,b()};Date.now()-v>66?requestAnimationFrame(t):t()}},g=e=>{-1===f.indexOf(e)&&f.push(e),b()};var w,x;w=p,x=((e,t,n,o)=>{const[r,s]=e.hook(e,t,n,o);return[r,t=>{const n=s(t);return r!==n&&g(e.context),n}]}),o.set(w,x);const y=new(WeakMap||Map),M=(e,t)=>{const n=d();n.hasAttribute(e)||void 0===t||n.setAttribute(e,t);const o=n.getAttribute(e);let r;return y.has(n)?r=y.get(n):(r=new MutationObserver(e=>{g(n)}),y.set(n,r),r.observe(n,{attributes:!0})),[o,t=>{r.disconnect(),n.setAttribute(e,t),r.observe(n,{attributes:!0})}]},A=s((e,t,n)=>{const o=e.context;let r=e.v;if(!r){let s=!1;if(void 0===o[t]||o.hasOwnProperty(t)){let e=o[t]||n;Object.defineProperty(o,t,{set:t=>{e!==t&&(e=t,s||g(o))},get:()=>e})}r=(e=>{s=!0,o[t]=e,s=!1}),void 0===o[t]&&r(n),e.v=r}return[o[t],r]}),O=s((e,t)=>{e.context.renderer=t});function P(e,t,n){customElements.define(e,class extends HTMLElement{constructor(){super(),this.shadowRoot||this.attachShadow(Object.assign({mode:"open"},n)),g(this)}renderer(e,t){e&&!(e instanceof NodeList?t.contains(e[0]):t.contains(e))&&(t.innerHTML="",e instanceof NodeList?e.forEach(e=>t.appendChild(e)):t.appendChild(e))}render(){const e=c(t,this);return this.renderer(e,this.shadowRoot)}})}export{d as useHostElement,M as useAttribute,A as useProp,O as useRenderer,P as component,p as useReducer,h as useState,u as useEffect};
//# sourceMappingURL=index.esm.min.js.map
