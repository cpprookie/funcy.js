const t=Symbol("outside_run");let e,n=t;const o=new(WeakMap||Map),s=()=>{n=t},r=(s,r)=>(...a)=>{if(n.context===t)throw new Error("Hook was called outside of run()!");e++;const i=(t=>{const s=o.get(n.context);void 0===s[e]&&(s[e]={});const r=s[e],a=n.onStateChange;return{onCleanUp(t){r.cleanUp=t},beforeNextRun(t){r.beforeNextRun=t},afterCurrentRun(t){r.afterCurrentRun=t},getApi:()=>n.api,getContext:()=>n.context,getState:t=>(void 0===r.state&&(r.state=t),r.state),setState(e,n=!1){let o=r.state;r.state=e,!n&&a&&a(t,o,e)}}})(s);return r(...a,i)};function a(t,e,n){let o=n;for(;o--;){const s=e[n-o-1];s[t]&&(s[t](),s[t]=void 0)}}const i=r("useReducer",(t,e,{getState:n,setState:o})=>{const s=n(e);return[s,e=>{o(t(s,e))}]}),c=r("useState",t=>{const[e,n]=i((t,e)=>e.value,t);return[e,t=>n({type:"set_state",value:t})]}),u=r("useEffect",(t,...e)=>{let n;e.length>1&&(n=e[0]);const{getState:o,setState:s,onCleanUp:r,afterCurrentRun:a}=e[e.length-1];let{values:i,cleanUp:c}=o({}),u=!1;if(i!==n&&i&&i.length>0){u=!0;let t=i.length;for(;t--;)if(n[t]!==i[t]){u=!1;break}i=n}u||(c&&c(),a(()=>{c=t(),s({values:n,cleanUp:c}),r(c?()=>{c()}:void 0)}))}),d=new Map;let h=!1;const l=[],p=r=>((r,{context:i,api:c,onStateChange:u=(()=>{})}={})=>{if(i||(i=r),!(i instanceof Object))throw new Error("Run was called without a valid object context!");if(n!==t)throw new Error("Run was called before the end of the previous run!");n={context:i,api:c,onStateChange:u},e=-1;let d=!1;o.has(i)||(o.set(i,[]),d=!0);const h=o.get(n.context),l=h.length;a("beforeNextRun",h,l);const p=r();return p instanceof Promise?p.then(t=>(a("afterCurrentRun",h,d?h.length:l),s(),t)):(a("afterCurrentRun",h,d?h.length:l),s(),p)})(()=>r.render(),{context:r,onStateChange:t=>{"useReducer"===t&&C(r)}}),g=async()=>{const t=l.length;h=!0,Promise.resolve().then(async()=>{let e=t;for(;e--;)await p(l[t-e-1]);l.splice(0,t),h=!1,l.length>0&&g()})},C=(t,e)=>{(-1===l.indexOf(t)&&!0===t._isConnected||e)&&l.push(t),h||g()},f=t=>{const e=d.get(t);return d.delete(t),e};let w=1e5;const b=t=>{return{"data-props":(t=>{let e=w.toString(16);return w++,e.length%2&&(e="0"+e),d.set(e,t),e})(t)}},x=(t,e)=>{(t instanceof NodeList?e.contains(t[0]):e.contains(t))||(e.innerHTML="",t instanceof NodeList?t.forEach(t=>e.appendChild(t)):e.appendChild(t))},S=new Map;const _=(t,e,n={})=>{S.has(t)?console.warn(`Component ${t} was already defined.`):(S.set(t,e),function(t,e={}){customElements.define(t,class extends HTMLElement{constructor(){super(),this._props={},this._renderer=x,this._isConnected=!1}connectedCallback(){this._shadowRoot||(this._shadowRoot=this.attachShadow({mode:"open",...e.shadowOptions?e.shadowOptions:{}})),this._isConnected||(this._isConnected=!0,C(this))}disconnectedCallback(){this._isConnected&&(this._isConnected=!1,C(this,!0))}render(){const e=this.getAttribute("data-props");e&&(this._props=f(e),this.skipQueue=!0,this.removeAttribute("data-props"));const n=S.get(t)(this._props);this._renderer(n,this._shadowRoot),this.init=!1}attributeChangedCallback(t,e,n){this.init||(this.skipQueue||e===n||C(this),this.skipQueue=!1)}static get observedAttributes(){let t=["data-props"];return e.observedAttributes&&(t=t.concat(e.observedAttributes)),t}})}(t,n))},R=r("useHostElement",({getContext:t})=>t()),v=r("useShadowRoot",({getContext:t})=>t()._shadowRoot),m=r("useRenderer",(t,{getContext:e,getState:n})=>{const o=n(t);e()._renderer=o}),k=r("useAttribute",(t,{getContext:e})=>{const n=e();return[n.getAttribute(t),e=>{n.skipQueue=!0,n.setAttribute(t,e)}]}),A=r("useCSS",(t,...e)=>{let n;e.pop(),n=(n=t instanceof Array?t.map((t,n)=>e[n]?t+e[n]:t).join(""):t).replace(/ +(?= )/g,"").replace(/\n/g,"");const o=v(),s=document.createElement("style");s.innerHTML=n,u(()=>(o.appendChild(s),()=>{o.removeChild(s)}))}),E=r("useExposeMethod",(t,e,{getContext:n})=>{n()[t]=((...t)=>e(...t))}),M=r("useConnectedState",({getContext:t})=>{return t()._isConnected});export{_ as defineComponent,b as prps,r as createHook,i as useReducer,c as useState,u as useEffect,k as useAttribute,A as useCSS,E as useExposeMethod,m as useRenderer,R as useHostElement,v as useShadowRoot,M as useConnectedState};
//# sourceMappingURL=core.min.mjs.map
