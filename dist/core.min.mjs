const t=Symbol("outside_run");let e=t;const n=new(WeakMap||Map),o=()=>{e=t},s=(o,s)=>(...a)=>{if(e.context===t)throw new Error("Hook was called outside of run()!");e.hookStateIndex++;const r=(t=>{const o=n.get(e.context);void 0===o[e.hookStateIndex]&&(o[e.hookStateIndex]={});const s=o[e.hookStateIndex],a=e.onStateChange;return{onCleanUp(t){s.cleanUp=t},beforeNextRun(t){s.beforeNextRun=t},afterCurrentRun(t){s.afterCurrentRun=t},getContext:()=>e.context,getState:t=>(void 0===s.state&&(s.state=t),s.state),setState(e,n=!1){let o=s.state;s.state=e,!n&&a&&a(t,o,e)}}})(o);return s(...a,r)};function a(t,e,n){let o=n;for(;o--;){const s=e[n-o-1];s[t]&&(s[t](),s[t]=void 0)}}const r=t=>{const e=n.get(t);a("cleanUp",e,e.length),n.delete(t)},i=s("useReducer",(t,e,{getState:n,setState:o})=>{const s=n(e);return[s,e=>{o(t(s,e))}]}),c=s("useState",t=>{const[e,n]=i((t,e)=>e.value,t);return[e,t=>n({type:"set_state",value:t})]}),u=s("useEffect",(t,...e)=>{let n;e.length>1&&(n=e[0]);const{getState:o,setState:s,onCleanUp:a,afterCurrentRun:r}=e[e.length-1];let{values:i,cleanUp:c}=o({}),u=!1;if(i!==n&&i&&i.length>0){u=!0;let t=i.length;for(;t--;)if(n[t]!==i[t]){u=!1;break}i=n}u||(c&&c(),r(()=>{c=t(),s({values:n,cleanUp:c}),a(c?()=>{c()}:void 0)}))}),h=new Map;let d=!1;const l=[],p=t=>((t,...s)=>{if("function"==typeof t&&(t={context:t,function:t}),!(t.context instanceof Object))throw new Error("Run was called without a valid object context!");(e=t).hookStateIndex=-1;let r=!1;n.has(e.context)||(n.set(e.context,[]),r=!0);const i=n.get(e.context),c=i.length;a("beforeNextRun",i,c);const u=t.function(...s);return u instanceof Promise?u.then(t=>(a("afterCurrentRun",i,r?i.length:c),o(),t)):(a("afterCurrentRun",i,r?i.length:c),o(),u)})({context:t,onStateChange:(t,e,n)=>{console.log(t,e,n)},function:()=>t.render(),onStateChange:e=>{"useReducer"===e&&C(t)}}),g=async()=>{const t=l.length;d=!0,Promise.resolve().then(async()=>{let e=t;for(;e--;)await p(l[t-e-1]);l.splice(0,t),d=!1,l.length>0&&g()})},C=(t,e)=>{(-1===l.indexOf(t)&&!0===t._isConnected||e)&&l.push(t),d||g()},f=t=>{const e=h.get(t);return h.delete(t),e};let x=1e5;const w=t=>{return{"data-props":(t=>{let e=x.toString(16);return x++,e.length%2&&(e="0"+e),h.set(e,t),e})(t)}},S=(t,e)=>{(t instanceof NodeList?e.contains(t[0]):e.contains(t))||(e.innerHTML="",t instanceof NodeList?t.forEach(t=>e.appendChild(t)):e.appendChild(t))},b=new Map;const _=(t,e,n={})=>{b.has(t)?console.warn(`Component ${t} was already defined.`):(b.set(t,e),function(t,e={}){customElements.define(t,class extends HTMLElement{constructor(){super(),this._props={},this._renderer=S,this._isConnected=!1}connectedCallback(){this._shadowRoot||(this._shadowRoot=this.attachShadow({mode:"open",...e.shadowOptions?e.shadowOptions:{}})),this._isConnected||(this._isConnected=!0,C(this))}disconnectedCallback(){this._isConnected&&(this._isConnected=!1,C(this))}destroy(){this.parentElement.removeChild(this),r(this)}async render(){const e=this.getAttribute("data-props");e&&(this._props=f(e),this.skipQueue=!0,this.removeAttribute("data-props"));const n=await Promise.resolve().then(()=>b.get(t)(this._props));await this._renderer(n,this._shadowRoot),this.init=!1}attributeChangedCallback(t,e,n){this.init||(this.skipQueue||e===n||C(this),this.skipQueue=!1)}static get observedAttributes(){let t=["data-props"];return e.observedAttributes&&(t=t.concat(e.observedAttributes)),t}})}(t,n))},R=s("useAttribute",(t,{getContext:e})=>{const n=e();return[n.getAttribute(t),e=>{n.skipQueue=!0,n.setAttribute(t,e)}]}),m=s("useCSS",(t,...e)=>{const{getContext:n}=e.pop();let o;o=(o=t instanceof Array?t.map((t,n)=>e[n]?t+e[n]:t).join(""):t).replace(/ +(?= )/g,"").replace(/\n/g,"");const s=n()._shadowRoot,a=document.createElement("style");a.innerHTML=o,u(()=>(s.appendChild(a),()=>{s.removeChild(a)}))}),v=s("useExposeMethod",(t,e,{getContext:n})=>{n()[t]=((...t)=>e(...t))}),k=s("useRenderer",(t,{getContext:e,getState:n})=>{const o=n(t);e()._renderer=o}),y=s("useHostElement",({getContext:t})=>t()),E=s("useShadowRoot",({getContext:t})=>t()._shadowRoot),A=s("useConnectedState",({getContext:t})=>{return t()._isConnected});export{_ as defineComponent,w as prps,s as createHook,i as useReducer,c as useState,u as useEffect,R as useAttribute,m as useCSS,v as useExposeMethod,k as useRenderer,y as useHostElement,E as useShadowRoot,A as useConnectedState};
//# sourceMappingURL=core.min.mjs.map
